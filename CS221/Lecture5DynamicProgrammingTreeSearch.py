# -*- coding: utf-8 -*-
"""StanfordCS221.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1W2E3477MeRfHlijEl0Jy859u0NlekX3J
"""

#Lecture 5
'''
Tram Search Problem:
Imagine streets with blocks are numbered from 1 to n. 
Walking from block s to block s+1 takes 1 minute
Taking a magic tram from block s to block 2s takes 2 minutes

Question: How to travel from 1 to n in the least time?
'''

#Throughout all lectures, Professor Liang and Professor Sadigh emphasize a "Model/Inference/Learning" paradign
#Model=Problem Setup (no algorithms, just setting the problem structure)
#Inference=Algorithms/predictions
#Learning=Learn the parameters of the model (if not available)

#Model
class TransportationProblem(object):
  def __init__(self,N):
    self.N=N
  def startState(self):
    return 1
  def isEnd(self,state):
    if state==self.N:
      return True
  def SuccandCost(self,state):
    #For the state you are currently in, return (action/newState/cost)
    result=[]
    if state+1<=self.N:
      result.append(('walk',state+1,1))
    if state*2<=self.N:
      result.append(('tram',state*2,2))
    return result

problem=TransportationProblem(10)
#Check to see if works
#print(problem.SuccandCost(5))
#print(problem.SuccandCost(9))

#Neatly format solution
def printSolution(CostAndPath):
  cost=CostAndPath[0]
  totalpath=CostAndPath[1]
  print('Total Cost: {}'.format(cost))
  for path in totalpath:
    print(path)

#First Algorithm: Backtracking Search

#Inference
def backTrackingSearch(problem):
  bestCostAndPath={
   'cost':float('+inf'),
   'path':None
  }
  history=[]
  totalCost=0
  def recurse(state,history,totalcost):
    if problem.isEnd(state):
      if bestCostAndPath['cost']>totalcost:
        bestCostAndPath['cost']=totalcost
        bestCostAndPath['path']=history  
      return 
    for action,nextstate,cost in problem.SuccandCost(state):
      recurse(nextstate,history+[(action,nextstate)],totalcost+cost)

  recurse(problem.startState(),history,totalCost)
  return (bestCostAndPath['cost'],bestCostAndPath['path'])

problem=TransportationProblem(100)

#printSolution(backTrackingSearch(problem))

#Second Algorithm: Dynammic Programming (only works for acyclic graphs)
def dynammicProgramming(problem):
  cache={}
  result=float('+inf')
  def futureCost(state):
    if problem.isEnd(state):
      return 0
    if state in cache:
      return cache[state]

    result=min(cost+futureCost(nextstate) for action,nextstate,cost in problem.SuccandCost(state))

    #Alternative method to find result
    #for action,nextstate,cost in problem.SuccandCost(state):
    #  result=min(result,cost+futureCost(nextstate,result)) 

    cache[state]=result
    return result
  return futureCost(problem.startState())

print('Min Cost: {}'.format(dynammicProgramming(problem)))

#Third Algorithm: Uniform Cost Search (helps to deal with cycles); Similar to Dijstra's